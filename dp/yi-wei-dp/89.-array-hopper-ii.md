# 89. Array Hopper II



Given an array A of non-negative integers, you are initially positioned at index 0 of the array. **A\[i\] means the maximum jump distance from index i \(you can only jump towards the end of the array\).** Determine the minimum number of jumps you need to reach the end of array. If you can not reach the end of the array, return -1.

**Assumptions**

* The given array is not null and has length of at least 1.

**Examples**

* {3, 3, 1, 0, 4}, the minimum jumps needed is 2 \(jump to index 1 then to the end of array\)
* {2, 1, 1, 0, 2}, you are not able to reach the end of array, return -1 in this case.

### 题意：

最少几步跳到终点

### 思路：

base case：

* 站在终点 M\[n-1\] = 0, 需要0步

induction rule:

* M\[i\] 代表了最少几步可以从i到终点
* M\[i\] = 1步 + A\[i\]个落脚点中取最小

```java
public class Solution {
  public int minJump(int[] array) {
    // Write your solution here
    if(array == null || array.length == 0) {
      return -1;
    }
    int n = array.length;
    int[] m = new int[n];
    m[n-1] = 0;
    for(int i = n - 2; i >= 0; i--) {
     if(i + array[i] >= n - 1){
       m[i] = 1;
     }else {
       m[i] = Integer.MAX_VALUE;
       for(int j = 1; j <= array[i]; j++) {
         //翻memo 找最小 memo不能是max_value;
          m[i] = Math.min(m[i], m[i+j]);
       }
       if(m[i] != Integer.MAX_VALUE) {
         m[i] = m[i] + 1;
       }
     }
    }
    return m[0] != Integer.MAX_VALUE ? m[0] : -1;
  }
}

```

