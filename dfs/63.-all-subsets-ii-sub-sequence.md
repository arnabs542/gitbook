# 63. All Subsets II（sub-sequence）

### Description：

Given a set of characters represented by a String, return a list containing all subsets of the characters. Notice that each subset returned will be sorted to remove the sequence.

**Assumptions**

* There could be duplicate characters in the original set.

​**Examples**

* Set = "abc", all the subsets are \["", "a", "ab", "abc", "ac", "b", "bc", "c"\]
* Set = "abb", all the subsets are \["", "a", "ab", "abb", "b", "bb"\]
* Set = "abab", all the subsets are \["", "a", "aa","aab", "aabb", "ab","abb","b", "bb"\]
* * Set = "", all the subsets are \[""\]
* Set = null, all the subsets are \[\]

![](../.gitbook/assets/image%20%2815%29.png)

### 方法：

1. 首先想到的是用hashset把重复的char给他去了。然后用subset1 的逻辑解决这个问题
2. 
### 思路：

* 虽然是all subset， 但是里面有重复值，每个重复值都是unique的。
* 先把input sort一下，如果出现连续的element，每个重复element指process一次。
* 一共有n 层， 每层2叉。

### 时间复杂度:

时间： O\(2^n\)  分2叉 一共n层

空间: O（n） 有个stringbuilder

### code:

```java
public class Solution {
  public List<String> subSets(String set) {
    // Write your solution here.
    List<String> res = new ArrayList<>();
    if(set == null) {
      return res;
    }
    StringBuilder sb = new StringBuilder();
    char[] array = set.toCharArray();
    Arrays.sort(array);
    helper(0, array, sb, res);
    return res;
  }
  private void helper(int index, char[] array, StringBuilder sb, List<String> res) {
    if(index == array.length) {
      res.add(sb.toString());
      return;
    }
    // case 1: add current letter 
    sb.append(array[index]);
    helper(index + 1, array, sb, res);
    sb.deleteCharAt(sb.length() - 1);
    //case 2: not to add current letter,  all the letter same as current letter should not be added as while.
    //while loop watch out for index out off bond 
    while(index < array.length - 1 && array[index] == array[index + 1]) {
      index++;
    }
    helper(index + 1, array, sb, res);
  }
}
```

