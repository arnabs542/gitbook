# stack（栈）

先进后出，后进西出。

### 应用场景：

1. 递归：
2. 表达式的转换和求值。
3. 树的遍历
4. dfs。

### Java deque的api \(use deque instead of stack\(legacy\)\)

* offerFirst
* pollFirst
* peekFirst
* size

### 用array来实现stack：

1. 定义一个top来表示栈顶，初始化为-1 
2. 入栈：当数据入栈时，判断是否栈满， stack\[++top\] = data。
3. 出栈： 判断是否为空，return stack\[top--\];

### 用stack去实现一个计算器：

1.   遍历input array
2. 如果是数字就放入栈中
3. 如果是符合， 
   1. 如果符号栈为空，直接加入
   2. 如果符号栈不为空，判断当前运算符是否比top运算符优先。
      1. **如果优先**，就直接入栈，因为还没有读到操作符后面的那个数字没办法现在运算。
      2. 如果不优先，就pop出top运算符，和2个数字进行运算，并将算好的放回去，然后将当前运算符再push进stack。
4. 遍历完，开始pop数字stack和符号栈，开始运算
5. 最后数字栈里只会有一个数字。 

### 如何将中缀表达式转为后缀表达式：

i.e  将1+\(\(2+3\) \* 4） - 5  = &gt; 1 2 3 + 4 \* + 5 - 

1. 建2个栈， 一个用来存运算符和括号\(s1\)，一个用来输出结果（s2）。
2. iterate 这个中缀表达式
3. 遇到数字=》加入s2
4. 遇到括号：
   1. 左括号直接入栈
   2. 右括号，把s1的运算符加入到s2中，知道遇到左括号。
5. 遇到操作符：去和top做优先级比较
   1. 如果没有top，即stack为空，直接加入
   2. 如果top是\( ，直接加入
   3. 如果cur优先级大于top，直接入栈
   4. 如果cur优先级低于或等于top，说明可以执行top这个操作符了，把top放入s2，再拿cur和之后的top做对比。
6. 重复以上操作直到iteration结束。

